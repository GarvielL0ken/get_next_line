

//include stuffs

//one big function(const int fd, char **line)
{
	declaration of neccesary variables 
	int i, j, pos, read_ret;
	static char buff;
	
	if the file is not valid or line is NULL
		return (-1)
	if (!buff)
		buff = strnew(BUFFSIZE + 1)
	line can either be malloc(ed) to a massive size as it is in my submision or small and appended to later
	
	keep looping while:
					 the inner loop has reached the end of buff
					 the end of buff is not a newline
					 and read() read BUFF_SIZE chars to buff
	{
		if (buff[0] == '\0')
			read_ret = read(fd, buff, BUFF_SIZE)
		buff[read_ret] = '\0' //to ensure that only what has been read most recently is considered
		j = 0;
		loop through buff while the current charcter isnt a newline or a NULL character and j < BUFF_SIZE
		{
			copy current char (buff[j) to line (*(*line + i)) 
		}
		if buff contains a newline char
			shift all chars after \n to the begining of buff and add a \0 after the last char to be shifted
		else
			buff[0] == '\0' //so that line 21 will be executed
	}
	determine whether or not a line was read, there is nothing left to read or an error occured between the last read and now and return 1, 0 or -1 repectively
}
